// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: incidents.sql

package db

import (
	"context"
)

const createIncident = `-- name: CreateIncident :one
INSERT INTO
  incidents (monitor_id, reason)
VALUES
  (?, ?) RETURNING id, monitor_id, reason, resolved_at, created_at
`

type CreateIncidentParams struct {
	MonitorID int64   `json:"monitorId"`
	Reason    *string `json:"reason"`
}

func (q *Queries) CreateIncident(ctx context.Context, arg *CreateIncidentParams) (*Incident, error) {
	row := q.queryRow(ctx, q.createIncidentStmt, createIncident, arg.MonitorID, arg.Reason)
	var i Incident
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Reason,
		&i.ResolvedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteIncident = `-- name: DeleteIncident :exec
DELETE FROM incidents
WHERE
  id = ?
`

func (q *Queries) DeleteIncident(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteIncidentStmt, deleteIncident, id)
	return err
}

const getIncident = `-- name: GetIncident :one
SELECT
  id, monitor_id, reason, resolved_at, created_at
FROM
  incidents
WHERE
  id = ?
`

func (q *Queries) GetIncident(ctx context.Context, id int64) (*Incident, error) {
	row := q.queryRow(ctx, q.getIncidentStmt, getIncident, id)
	var i Incident
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Reason,
		&i.ResolvedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getIncidents = `-- name: GetIncidents :many
SELECT
  id, monitor_id, reason, resolved_at, created_at
FROM
  incidents
WHERE
  monitor_id = ?
`

func (q *Queries) GetIncidents(ctx context.Context, monitorID int64) ([]*Incident, error) {
	rows, err := q.query(ctx, q.getIncidentsStmt, getIncidents, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Incident
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Reason,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorIncidents = `-- name: GetMonitorIncidents :many
SELECT
  id, monitor_id, reason, resolved_at, created_at
FROM
  incidents
WHERE
  monitor_id = ?
ORDER BY
  created_at DESC
LIMIT
  ?
`

type GetMonitorIncidentsParams struct {
	MonitorID int64 `json:"monitorId"`
	Limit     int64 `json:"limit"`
}

func (q *Queries) GetMonitorIncidents(ctx context.Context, arg *GetMonitorIncidentsParams) ([]*Incident, error) {
	rows, err := q.query(ctx, q.getMonitorIncidentsStmt, getMonitorIncidents, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Incident
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Reason,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveIncident = `-- name: ResolveIncident :one
UPDATE incidents
SET
  resolved_at = CURRENT_TIMESTAMP
WHERE
  id = ? RETURNING id, monitor_id, reason, resolved_at, created_at
`

func (q *Queries) ResolveIncident(ctx context.Context, id int64) (*Incident, error) {
	row := q.queryRow(ctx, q.resolveIncidentStmt, resolveIncident, id)
	var i Incident
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Reason,
		&i.ResolvedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const updateIncident = `-- name: UpdateIncident :one
UPDATE incidents
SET
  reason = COALESCE(?, reason)
WHERE
  id = ? RETURNING id, monitor_id, reason, resolved_at, created_at
`

type UpdateIncidentParams struct {
	Reason *string `json:"reason"`
	ID     int64   `json:"id"`
}

func (q *Queries) UpdateIncident(ctx context.Context, arg *UpdateIncidentParams) (*Incident, error) {
	row := q.queryRow(ctx, q.updateIncidentStmt, updateIncident, arg.Reason, arg.ID)
	var i Incident
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Reason,
		&i.ResolvedAt,
		&i.CreatedAt,
	)
	return &i, err
}
